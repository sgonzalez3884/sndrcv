#!/usr/bin/perl -w

use strict;
use warnings;

use Net::SFTP;
use Net::FTP;
use WWW::Curl::Easy;
use Crypt::GPG;

use File::Copy;
use File::Path;
use File::Basename;
use Data::Dumper;
use Config::General;
use POSIX qw{ strftime };
use Cwd qw{ abs_path };

########################################################################################################
# Constants
########################################################################################################

use constant P_ERROR  => -1;
use constant P_PROG   =>  1;
use constant P_INFO   =>  2;
use constant P_DEBUG  =>  3;
use constant P_DEBUG1 =>  3;
use constant P_DEBUG2 =>  4;
use constant P_DEBUG3 =>  5;
use constant P_DEBUG4 =>  6;
use constant P_DEBUG5 =>  7;

########################################################################################################
# Globals
########################################################################################################

my($fh);			# Text output filehandle
my($verbosity) = P_PROG;	# Current verbosity level

########################################################################################################
# Subroutines
########################################################################################################

# myprint()		Conditionally print messages based on the current verbosity, and message level
# 
# input parms		$level	Passed message severity level
# 			@_	Variable lenght argument list parseable by printf
#
# returns		none

sub myprint(@)
{
	my($level) = shift;

	if($verbosity >= $level) {
		printf(strftime("%b %d %T ", localtime));
		printf(@_);
	}
}

# get_progpath()	Detect the current running script's path & name
#
# input parms	none
#
# returns	$prog	The current running script's name
# 		$path	The current running script's path

sub get_progpath() {
	if($0 =~ m#^[^/]#) {
		return fileparse(abs_path(abs_path(".") . '/' . $0));
	} else {
		return fileparse($0);
	}
}

# validate_config()	Check current config for correctness & completeness
#
# input parms	\%config	Configuration values
#
# returns	none

sub validate_config($) {

	my($config) = shift;

	myprint(P_DEBUG5, "Read configuration as:\n");
	myprint(P_DEBUG5, Dumper($config));

	# Connection level loop
	foreach my $conn (sort(keys %{$config})) {

		# Required fields
		foreach my $fld ("Server", "ConnType") {
			if(!defined($config->{$conn}->{$fld}) || $config->{$conn}->{$fld} eq "") {
				myprint(P_ERROR, "Missing required field $fld in Connection $conn!\n") and die;
			}
		}

		# Set default values
		foreach my $fldval (
			["User", ""],
			["AuthType", "Password"],
			["AuthData", ""],
			["Verbosity", P_INFO],
			["LogFile", ""],
			["Active", "0"]) {

			if(!defined($config->{$conn}->{$fldval->[0]}) || $config->{$conn}->{$fldval->[0]} eq "") {
				$config->{$conn}->{$fldval->[0]} = $fldval->[1];
			}
		}
		if($config->{$conn}->{Verbosity} >= P_DEBUG) {
			$config->{$conn}->{Debug} = 1;
		} else {
			$config->{$conn}->{Debug} = 0;
		}

		# Check set values
		if((grep $config->{$conn}->{ConnType},("ftp","ftps","sftp")) == 0) {
			myprint(P_ERROR, "Invalid ConnType '$config->{$conn}->{ConnType}' in Connection $conn\n") and die;
		}

		if((grep $config->{$conn}->{AuthType},("Password","Identity")) == 0) {
			myprint(P_ERROR, "Unknown AuthType '$config->{$conn}->{AuthType}' in Connection $conn\n") and die;
		}
		if($config->{$conn}->{AuthType} eq "Identity" &&
			$config->{$conn}->{ConnType} ne "sftp") {
			myprint(P_ERROR, "AuthType '$config->{$conn}->{AuthType}' specified for non sftp Connection $conn\n") and die;
		}
		if(!($config->{$conn}->{Verbosity} =~ /^(-1)|([1234567])$/)) {
			myprint(P_ERROR, "Unknown Verbosity flag '$config->{$conn}->{Verbosity}' specified Connection $conn\n") and die;
		}
		if(!($config->{$conn}->{Active} =~ /^[01]$/)) {
			myprint(P_ERROR, "Unknown Active flag '$config->{$conn}->{Active}' specified Connection $conn\n") and die;
		}

		if(defined($config->{$conn}->{Download})) {
			# Download level loop
			foreach my $prf (sort(keys %{$config->{$conn}->{Download}})) {
				# Required fields
				foreach my $fld ("RemoteDir", "Regex", "LocalDir", "TempDir") {
					if(!defined($config->{$conn}->{Download}->{$prf}->{$fld}) || 
						$config->{$conn}->{Download}->{$prf}->{$fld} eq "") {
						myprint(P_ERROR, "Missing required field $fld in Download profile $prf, Connection $conn!\n") and die;
					}
				}

				# Set default values
				foreach my $fldval (
					["ArchiveDir", ""],
					["ArchivePst", ""],
					["CryptType", "None"],
					["CryptData", ""],
					["TransferType","BINARY"],
					["MakeList", "0"],
					["Active", "0"],
					["Debug", "0"]) {

					if(!defined($config->{$conn}->{Download}->{$prf}->{$fldval->[0]}) ||
						$config->{$conn}->{Download}->{$prf}->{$fldval->[0]} eq "") {
						$config->{$conn}->{Download}->{$prf}->{$fldval->[0]} = $fldval->[1];
					}
				}

				# Check set values
				if((grep $config->{$conn}->{Download}->{$prf}->{CryptType},("PGP","None")) == 0) {
					myprint(P_ERROR, "Unknown CryptType '$config->{$conn}->{Download}->{$prf}->{CryptType}' in Download profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{Download}->{$prf}->{CryptType} eq "PGP" and
					$config->{$conn}->{Download}->{$prf}->{CryptData} eq "") {
					myprint(P_ERROR, "CryptType '$config->{$conn}->{Download}->{$prf}->{CryptType}' requires CryptData in Download profile $prf, Connection $conn\n") and die;
				}
				if((grep $config->{$conn}->{Download}->{$prf}->{TransferType},("BINARY","ASCII")) == 0) {
					myprint(P_ERROR, "Unknown TransferType flag '$config->{$conn}->{Download}->{$prf}->{Transfertype}' in Download profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Download}->{$prf}->{MakeList} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown MakeList flag '$config->{$conn}->{Download}->{$prf}->{MakeList}' in Download profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Download}->{$prf}->{Debug} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown Debug flag '$config->{$conn}->{Download}->{$prf}->{Debug}' in Download profile $prf, Connection $conn\n") and die;
				}
			}
		}

		if(defined($config->{$conn}->{Upload})) {
			# Upload level loop
			foreach my $prf (sort(keys %{$config->{$conn}->{Upload}})) {
				# Required fields
				foreach my $fld ("RemoteDir", "Regex", "LocalDir", "TempDir") {
					if(!defined($config->{$conn}->{Upload}->{$prf}->{$fld}) || 
						$config->{$conn}->{Upload}->{$prf}->{$fld} eq "") {
						myprint(P_ERROR, "Missing required field $fld in Upload profile $prf, Connection $conn!\n") and die;
					}
				}

				# Set default values
				foreach my $fldval (
					["ArchiveDir", ""],
					["ArchivePst", ""],
					["CryptType", "None"],
					["CryptData", ""],
					["TransferType","BINARY"],
					["Active", "0"],
					["Debug", "0"]) {

					if(!defined($config->{$conn}->{Upload}->{$prf}->{$fldval->[0]}) ||
						$config->{$conn}->{Upload}->{$prf}->{$fldval->[0]} eq "") {
						$config->{$conn}->{Upload}->{$prf}->{$fldval->[0]} = $fldval->[1];
					}
				}

				# Check set values
				if((grep $config->{$conn}->{Upload}->{$prf}->{CryptType},("PGP","None")) == 0) {
					myprint(P_ERROR, "Unknown CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' in Upload profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{Upload}->{$prf}->{CryptType} eq "PGP") {
					if($config->{$conn}->{Upload}->{$prf}->{CryptData} eq "") {
						myprint(P_ERROR, "CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' requires CryptData in Upload profile $prf, Connection $conn\n") and die;
					} elsif(!($config->{$conn}->{Upload}->{$prf}->{CryptData}) =~ m/^[^,]+,[^,]+$/) {
						myprint(P_ERROR, "CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' requires 2 items in CryptData in Upload profile $prf, Connection $conn\n") and die;
					}

				}
				if((grep $config->{$conn}->{Upload}->{$prf}->{TransferType},("BINARY","ASCII")) == 0) {
					myprint(P_ERROR, "Unknown TransferType flag '$config->{$conn}->{Upload}->{$prf}->{Transfertype}' in Upload profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Upload}->{$prf}->{Debug} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown Debug flag '$config->{$conn}->{Upload}->{$prf}->{Debug}' in Upload profile $prf, Connection $conn\n") and die;
				}
			}
		}
	}

	myprint(P_DEBUG5, "Cleaned configuration:\n");
	myprint(P_DEBUG5, Dumper($config));
}

# get_config()	Uses Config::General to parse a config file into a %hash
#
# input parms	$config_path	Path to config
#
# returns	\%config	Configuration values

sub get_config($) {

	my($config_path) = shift;
	my($config_obj) = new Config::General($config_path);
	my($type, $config) = $config_obj->getall;

	validate_config($config);

	return $config;

}

# get_date()	Returns an array of values corresponding to time( now );
#
# input parms	None
#
# returns	\@date	Values corresponding to time( now );

sub get_date() {

	my(@date) = localtime(time);

	$date[0] = sprintf("%02d", $date[0]);		# %s%  Second
	$date[1] = sprintf("%02d", $date[1]);		# %m%  Minute
	$date[2] = sprintf("%02d", $date[2]);		# %h%  Hour
	$date[3] = sprintf("%02d", $date[3]);		# %D%  day of Month
	$date[4] = sprintf("%02d", ($date[4] + 1));	# %M%  Month
	$date[5] = sprintf("%04d", ($date[5] + 1900));	# %CY% Year 4-Dig
	$date[7] = sprintf("%03d", ($date[7] + 1));	# %J%  Day of Year
	$date[9] = substr($date[5],1,2);		# %C%  Century
	$date[10] = substr($date[5],3,2);		# %Y%  Year 2-Dig

	return \@date;

}

# var_replace()	Replace wildcard values in a string with current date values
#
# Wildcards replaced:
# %s%   Current Second          00-59 (60 on leap-second)
# %m%   Current Minute          00-59
# %h%   Current Hour            00-23
# %M%   Current Month           00-12
# %D%   Current Day of Month    00-31
# %CY%  Current 4-Dig Year      CCYY
# %C%   Current 2-Dig Century   CC
# %Y%   Current 2-Dig Year      YY
# %J%   Current Day of Year     001-366
#
# input parms	$str	String to operate on
# 		\@date	Date values to use for replacement
#
# returns	$str	modified string

sub var_replace($$) {
	my($str) = shift;
	my(@date) = @{(shift)};

	$str =~ s/[%]s[%]/$date[0]/g;
	$str =~ s/[%]m[%]/$date[1]/g;
	$str =~ s/[%]h[%]/$date[2]/g;
	$str =~ s/[%]D[%]/$date[3]/g;
	$str =~ s/[%]M[%]/$date[4]/g;
	$str =~ s/[%]CY[%]/$date[5]/g;
	$str =~ s/[%]J[%]/$date[7]/g;
	$str =~ s/[%]C[%]/$date[9]/g;
	$str =~ s/[%]Y[%]/$date[10]/g;

	return $str;
}

# download_loop()	Loop through download directory profiles, downloading whatever matches
#
# input parms		\%conn_prf	Connection Profile configuration values
# 			$conn		Connection Object
# 			\@date		Current date
#
# returns		0 on success
# 			1 on general failure

sub download_loop($$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($date) = shift;

	foreach my $key (keys %{$conn_prf->{Download}}) {
		my($dir) = $conn_prf->{Download}->{$key};

		if($dir->{Active} eq "0") {
			myprint(P_INFO, "Download profile $key is Inactive.\n");
			next;
		}

		# Replace %Variables%
		$dir->{LocalDir} = var_replace($dir->{LocalDir}, $date);
		$dir->{RemoteDir} = var_replace($dir->{RemoteDir}, $date);
		$dir->{ArchiveDir} = var_replace($dir->{ArchiveDir}, $date);
		$dir->{ArchivePst} = var_replace($dir->{ArchivePst}, $date);

		mkpath($dir->{LocalDir});
		if($dir->{ArchiveDir} ne "") {
			mkpath($dir->{ArchiveDir});
		}
		mkpath($dir->{TempDir});
		chdir($dir->{TempDir});

		myprint(P_INFO, "Getting file list for '$dir->{RemoteDir}'.\n");
		my(@list) = grep { $_ =~ m/$dir->{Regex}/i } ls_wrap($conn_prf, $conn, $dir->{RemoteDir});

		if($#list >= 0) {
			myprint(P_PROG, "Downloading all files matching /$dir->{Regex}/i in '$dir->{RemoteDir}'.\n");
			foreach my $file (@list) {
				myprint(P_INFO, "Receiving '$file'...\n");
				get_wrap($conn_prf, $conn, $file, $dir->{RemoteDir}, $dir->{TransferType});

				my($file2) = decrypt_wrap($dir, $file);

				if($dir->{Debug} eq "0") {

					if($file2 ne "") {
						my($file3) = $file;
						$file = $file2;
						$file2 = $file3;
					}

					myprint(P_INFO, "Copying file '$file' to '$dir->{LocalDir}'...\n");
					copy($dir->{TempDir} . '/' . $file, $dir->{LocalDir} . '/') 
						or (myprint(P_ERROR, "$!\n") and die);

					foreach my $arcfile ($file, $file2) {
						if($arcfile ne "") {
							if($dir->{ArchiveDir} ne "") {
								my($newfile) = $arcfile;
								if($newfile =~ m/^(.*)([.][^.]*)$/) {
									$newfile = $1 . $dir->{ArchivePst} . $2;
								} else {
									$newfile .= $dir->{ArchivePst};
								}
								myprint(P_INFO, "Moving file '$arcfile' to '$dir->{ArchiveDir}/$newfile'...\n");
								move($dir->{TempDir} . '/' . $arcfile, $dir->{ArchiveDir} . '/' . $newfile)
									or (myprint(P_ERROR, "$!\n") and die);
							} else {
								unlink($dir->{TempDir} . '/' . $arcfile);
							}
						}
					}
				}

				if($dir->{Debug} eq "0") {
					if($file2 ne "") {
						myprint(P_INFO, "Removing file '$file2' from server '$conn_prf->{Server}'...\n");
						rm_wrap($conn_prf, $conn, $file2, $dir->{RemoteDir});
					} else {
						myprint(P_INFO, "Removing file '$file' from server '$conn_prf->{Server}'...\n");
						rm_wrap($conn_prf, $conn, $file, $dir->{RemoteDir});
					}
				
				}
			}
		} else {
			myprint(P_PROG, "No files matching /$dir->{Regex}/i in '$dir->{RemoteDir}'.\n");
		}

		if($dir->{MakeList} eq "1") {
			my(@list) = grep { $_ =~ m/$dir->{Regex}/i } ls_wrap($conn_prf, "LocalDir", $dir->{LocalDir});
			if($#list >= 0) {
				open(OUT, "> " . $dir->{TempDir} . "/" . $key . ".lst")
						or (myprint(P_ERROR, "Can't open file " . $dir->{TempDir} . "/" . $key . ".txt for writing: $!\n") and
						die);
				foreach my $file (@list) {
					if($file =~ m/$dir->{Regex}/i) {
						print OUT "$file\n";
					}
				}
				close(OUT);

				if($dir->{Debug} eq "0") {
					myprint(P_INFO, "Moving file '$key.lst' to '$dir->{LocalDir}'...\n");
					move($dir->{TempDir} . '/' . $key . ".lst", $dir->{LocalDir} . '/')
						or (myprint(P_ERROR, "$!\n") and die);
				}
			}
		}
	}

	# FIXME: Do we need to actually do error checking?
	return 0;

}

# upload_loop()		Loop through upload directory profiles, uploading whatever matches
#
# input parms		\%conn_prf	Connection Profile configuration values
# 			$conn		Connection Object
# 			\@date		Current date
#
# returns		0 on success
# 			1 on general failure

sub upload_loop($$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($date) = shift;

	foreach my $key (keys %{$conn_prf->{Upload}}) {
		my($dir) = $conn_prf->{Upload}->{$key};

		if($dir->{Active} eq "0") {
			myprint(P_INFO, "Upload profile $key is Inactive.\n");
			next;
		}

		# Replace %Variables%
		$dir->{LocalDir} = var_replace($dir->{LocalDir}, $date);
		$dir->{RemoteDir} = var_replace($dir->{RemoteDir}, $date);
		$dir->{ArchiveDir} = var_replace($dir->{ArchiveDir}, $date);
		$dir->{ArchivePst} = var_replace($dir->{ArchivePst}, $date);

		mkpath($dir->{LocalDir});
		if($dir->{ArchiveDir} ne "") {
			mkpath($dir->{ArchiveDir});
		}
		mkpath($dir->{TempDir});
		chdir($dir->{TempDir});
	
		myprint(P_INFO, "Getting file list for '$dir->{LocalDir}'.\n");
		opendir(DIR, $dir->{LocalDir})
			or (myprint(P_ERROR, "Can't open directory '$dir->{LocalDir}': $!\n") and die);
		my(@list) = grep { -f $dir->{LocalDir} . "/" . $_ && /$dir->{Regex}/i } readdir(DIR);
		closedir(DIR);

		if($#list >= 0) {
			myprint(P_PROG, "Uploading all files matching /$dir->{Regex}/i in '$dir->{LocalDir}'.\n");
			foreach my $file (@list) {
				my($file2) = encrypt_wrap($dir, $file);

				if($file2 ne "") {
					my($file3) = $file;
					$file = $file2;
					$file2 = $file3;
				}

				myprint(P_INFO, "Sending '$file'...\n");
				put_wrap($conn_prf, $conn, $file, $dir->{LocalDir}, $dir->{RemoteDir}, $dir->{TransferType});

				if($dir->{Debug} eq "0") {
					foreach my $arcfile ($file, $file2) {
						if($arcfile ne "") {
							if($dir->{ArchiveDir} ne "") {
								my($newfile) = $arcfile;
								if($newfile =~ m/^(.*)([.][^.]*)$/) {
									$newfile = $1 . $dir->{ArchivePst} . $2;
								} else {
									$newfile .= $dir->{ArchivePst};
								}

								myprint(P_INFO, "Moving file '$arcfile' to '$dir->{ArchiveDir}/$newfile'...\n");
								move($dir->{LocalDir} . '/' . $arcfile, $dir->{ArchiveDir} . '/' . $newfile) 
									or (myprint(P_ERROR, "$!\n") and die);
							} else {
								unlink($dir->{LocalDir} . '/' . $arcfile);
							}
						}
					}
				}
			}
		
		} else {
			myprint(P_PROG, "No files matching /$dir->{Regex}/i in '$dir->{LocalDir}'.\n");
		}
	}

	# FIXME: Do we need to actually do error checking?
	return 0;

}

########################################################################################################
# Wrapper Subroutines
########################################################################################################

# curl_wrap()	Wrapper for curl->perform retries 'unknown PASV reply (13)' errors
#
# input parms	$conn		Connection Object
#
# returns	$retval		Retun value from perform

sub curl_wrap($) {
	my($conn) = shift;
	my($retval);
	my($retry_max) = 5;

	for(my($retry) = 1; $retry <= ($retry_max+1); $retry++) {
		$retval = $conn->perform;

		# Return if no error, or error is not 'unknown PASV reply (99)'
		if($retval == 0 or $retval != 13) {
			return $retval;
		}
		sleep 1; # Curl runs better if we sleep in-between performs?
		myprint(P_DEBUG, "Recieved ".$conn->strerror($retval)." ($retval). Retry attempt $retry of $retry_max\n");
	}

	return $retval;
}

# connect_wrap()	Connects to specified server
#
# input parms	\%conn_prf	Connection Profile configuration values
#
# returns	$conn		Connection Object

sub connect_wrap($) {
	my($conn_prf) = shift;

	my($conn);

	if($conn_prf->{ConnType} eq "sftp") {
		if($conn_prf->{AuthType} eq "Password") {
			myprint(P_PROG, "Logging in to server '$conn_prf->{Server}' as '$conn_prf->{User}' using PASSWORD...\n");
			$conn = Net::SFTP->new(
					$conn_prf->{Server},
					user => $conn_prf->{User}, 
					password => $conn_prf->{AuthData},
					debug => $conn_prf->{Debug}
				) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
		} else {
			myprint(P_PROG, "Logging in to server '$conn_prf->{Server}' as '$conn_prf->{User}' using IDENTITY...\n");
			$conn = Net::SFTP->new(
					$conn_prf->{Server},
					user => $conn_prf->{User}, 
					debug => $conn_prf->{Debug},
					ssh_args => [ 
						identity_files => [ $conn_prf->{AuthData} ]
					]
				) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
		}
	} elsif($conn_prf->{ConnType} eq "ftp") {
		myprint(P_PROG, "Logging in to server '$conn_prf->{Server}' as '$conn_prf->{User}' using PASSWORD...\n");
		$conn = Net::FTP->new(
				$conn_prf->{Server},
				Debug => $conn_prf->{Debug}
			) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
		$conn->login($conn_prf->{User}, $conn_prf->{AuthData})
			or (myprint(P_ERROR, "Cannot login to $conn_prf->{Server}: %s\n", $conn->message) and die);
	} elsif($conn_prf->{ConnType} eq "ftps") {
		myprint(P_PROG, "Logging in to server '$conn_prf->{Server}' as '$conn_prf->{User}' using PASSWORD...\n");
		$conn = new WWW::Curl::Easy;
		$conn->setopt(CURLOPT_FTP_SSL,1);
		$conn->setopt(CURLOPT_FTP_SSL_CCC,1);
		$conn->setopt(CURLOPT_SSL_VERIFYPEER,0);
		$conn->setopt(CURLOPT_FTP_USE_EPSV,0);
		$conn->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server});
		$conn->setopt(CURLOPT_USERPWD,$conn_prf->{User}.':'.$conn_prf->{AuthData});
		$conn->setopt(CURLOPT_VERBOSE,$conn_prf->{Debug});
	
		my($fileb);
		open($fileb, ">", "/dev/null");
		$conn->setopt(CURLOPT_WRITEDATA,$fileb);
		my $retval = curl_wrap($conn);
		close($fileb);
		myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: ".$conn->strerror($retval)." ($retval)\n") and die if($retval != 0);
	} else {
		myprint(P_ERROR, "Unknown ConnType $conn_prf->{ConnType}!\n") and die;
	}

	return $conn;

}

# disconnect_wrap()	Disconnects from specified server
#
# input parms	\%conn_prf	Connection Profile configuration values
#		$conn		Connection Object
#
# returns	none

sub disconnect_wrap($$) {
	my($conn_prf) = shift;
	my($conn) = shift;

	myprint(P_PROG, "Disconnecting from server '$conn_prf->{Server}'...\n");
	if($conn_prf->{ConnType} eq "sftp") {
		undef $conn;
	} elsif($conn_prf->{ConnType} eq "ftp") {
		$conn->quit;	
	} elsif($conn_prf->{ConnType} eq "ftps") {
		undef $conn;
	} else {
		myprint(P_ERROR, "Unknown ConnType $conn_prf->{ConnType}!\n") and die;
	}

}

# ls_wrap()	Get file list for specified directory via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
#		$conn		Connection Object
# 		$dir		Directory to list
#
# returns	@list	Directory Listing

sub ls_wrap($$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($dir) = shift;
	my(@list) = ();

	if($conn =~ /^Net::SFTP/) {
		foreach my $item ($conn->ls($dir)) {
			push @list, $item->{filename};
		}
	} elsif($conn =~ /^Net::FTP/) {
		foreach my $item ($conn->ls($dir)) {
			$item =~ s|^$dir[/\\]*||;
			push @list, $item;
		}
	} elsif($conn =~ /^WWW::Curl/) {
		$conn->setopt(CURLOPT_FTPLISTONLY,1);
		$conn->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$dir.'/');
		
		my($response_body) = "";
		open(my $fh, ">", \$response_body);
			$conn->setopt(CURLOPT_WRITEDATA,$fh);
			my $retval = curl_wrap($conn);
			myprint(P_ERROR, "Can't list directory $dir: ".$conn->strerror($retval)."\n") and die if($retval != 0);
		$conn->setopt(CURLOPT_FTPLISTONLY,0);
		close($fh);

		if(defined($response_body)) {
			foreach my $line (split(/\n|\r/, $response_body)) {
					chomp($line);
					$line =~ s/^\s+//g;
					$line =~ s/\s+$//g;
					push(@list, $line) if($line ne "");
			}
			undef $response_body;
		}
	} elsif($conn =~ /^LocalDir/) {
		opendir(DIR, $dir) 
			or (myprint(P_ERROR, "Can't open directory $dir: $!\n") and die);
		@list = readdir(DIR);
		closedir(DIR)
			or (myprint(P_ERROR, "Can't close directory $dir: $!\n") and die);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn\n") and die;
	}

	foreach my $item (@list) {
		myprint(P_DEBUG5, "List Entry: '$item'\n");
	}
	return @list;

}

# get_wrap()	Get specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
# 		$conn		Connection Object
# 		$file		File to get
# 		$dir		Directory file is located
#
# returns			0 on success
# 				1 on general failure

sub get_wrap($$$$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($file) = shift;
	my($dir) = shift;
	my($type) = shift;

	if($conn =~ /^Net::SFTP/) {
		$conn->get($dir . '/' . $file, $file);
		if(! -e $file) {
			myprint(P_ERROR, "Error receiving '$file'\n") and die;
		}
	} elsif($conn =~ /^Net::FTP/) {
		if($type eq "ASCII") {
			$conn->ascii();
		} else {
			$conn->binary();
		}

		$conn->get($dir . '/' . $file, $file)
			or (myprint(P_ERROR, "Error receiving '$file'\n") and die);
	} elsif($conn =~ /^WWW::Curl/) {
		if($type eq "ASCII") {
			$conn->setopt(CURLOPT_TRANSFERTEXT,1);
		} else {
			$conn->setopt(CURLOPT_TRANSFERTEXT,0);
		}
		$conn->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$dir.'/'.$file);
		my($fileb);
		open($fileb, "> $file");
			$conn->setopt(CURLOPT_WRITEDATA,$fileb);
			my $retval = curl_wrap($conn);
			# FIXME: We get 'Transferred a partial file (18) when we upload/downloai with ASCII? ignore... for now.
			myprint(P_ERROR, "Error receiving '$file': ".$conn->strerror($retval)." ($retval)\n") and
				die if(($retval != 0 and $type eq "BINARY") or ($retval != 0 and $retval != 18 and $type eq "ASCII"));
		close($fileb);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn\n") and die;
	}

	return 0;

}

# put_wrap()	Put specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
#		$conn		Connection Object
# 		$file		File to put
# 		$dir		Directory file is located
# 		$rmt_dir	Remote directory to put file
#
# returns			0 on success
# 				1 on general failure

sub put_wrap($$$$$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($file) = shift;
	my($dir) = shift;
	my($rmt_dir) = shift;
	my($type) = shift;

	if($conn =~ /^Net::SFTP/) {
		$conn->put($dir . '/' . $file, $rmt_dir . '/' . $file)
			or (myprint(P_ERROR, "Error sending '$file'\n") and die);
	} elsif($conn =~ /^Net::FTP/) {
		if($type eq "ASCII") {
			$conn->ascii();
		} else {
			$conn->binary();
		}

		$conn->put($dir . '/' . $file, $rmt_dir . '/' . $file)
			or (myprint(P_ERROR, "Error sending '$file'\n") and die);
	} elsif($conn =~ /^WWW::Curl/) {
		if($type eq "ASCII") {
			$conn->setopt(CURLOPT_TRANSFERTEXT,1);
		} else {
			$conn->setopt(CURLOPT_TRANSFERTEXT,0);
		}
		$conn->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$rmt_dir.'/'.$file);
		$conn->setopt(CURLOPT_UPLOAD,1);
		my($fileb);
 		open($fileb, "< $dir/$file");
			$conn->setopt(CURLOPT_INFILE,$fileb);
			my $retval = curl_wrap($conn);
			# FIXME: We get 'Transferred a partial file (18) when we upload/downloai with ASCII? ignore... for now.
			myprint(P_ERROR, "Error sending '$file': ".$conn->strerror($retval)." ($retval)\n") and
				die if(($retval != 0 and $type eq "BINARY") or ($retval != 0 and $retval != 18 and $type eq "ASCII"));
		close($fileb);
		$conn->setopt(CURLOPT_UPLOAD,0);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn\n") and die;
	}

	return 0;

}

# rm_wrap()	Remove specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
#		$conn		Connection Object
# 		$file		File to remove
# 		$dir		Directory file is located
#
# returns			0 on success
# 				1 on general failure

sub rm_wrap($$$$) {
	my($conn_prf) = shift;
	my($conn) = shift;
	my($file) = shift;
	my($dir) = shift;

	if($conn =~ /^Net::SFTP/) {
		$conn->do_remove($dir . '/' . $file);
	} elsif($conn =~ /^Net::FTP/) {
		$conn->delete($dir . '/' . $file);
	} elsif($conn =~ /^WWW::Curl/) {
		$conn->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/');
		$conn->setopt(CURLOPT_CUSTOMREQUEST,"DELE $dir/$file");
		my($fileb);
		open($fileb, "< $dir/$file");
			$conn->setopt(CURLOPT_INFILE,$fileb);
			my $retval = curl_wrap($conn);
			# FIXME: We get an unable to retrieve file when trying to delete? Unsure why, but ignore... for now.
			myprint(P_ERROR, "Error removing '$file': ".$conn->strerror($retval)." ($retval)\n") and 
				die if($retval != 0 and $retval != 19);
		close($fileb);
		$conn->setopt(CURLOPT_CUSTOMREQUEST,"");
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn\n") and die;
	}

	return 0;

}

# decrypt_wrap()	Conditionally decrypts files
#
# input parms	\%dir_prf	Directory Profile configuration values
#		$file		File to decrypt
#
# returns	$file2		Decrypted file on success
# 				Empty string on non encrypted file/no CryptType chosen

sub decrypt_wrap($$) {
	my($dir_prf) = shift;
	my($file) = shift;
	my($file2) = "";

	if($dir_prf->{CryptType} eq "PGP" and $file =~ m/^(.*)[.](asc|pgp)$/i) {
		$file2 = $1;

		myprint(P_INFO, "Decrypting $file with $dir_prf->{CryptType}/$dir_prf->{CryptData}\n");
		my($gpg) = new Crypt::GPG;
		$gpg->gpgbin('/usr/bin/gpg');
		$gpg->secretkey($dir_prf->{CryptData});
		$gpg->debug($dir_prf->{Debug});

		open(IN, "< $file")
			or (myprint(P_ERROR, "Can't open file $file for reading: $!\n") and die);
		my($data) = $gpg->decrypt([<IN>]);
		close(IN);
		open(OUT, "> $file2")
			or (myprint(P_ERROR, "Can't open file $file2 for writing: $!\n") and die);
		print OUT $data;
		close(OUT);
	}

	return $file2;
}

# encrypt_wrap()	Conditionally encrypts files
#
# input parms	\%dir_prf	Directory Profile configuration values
#		$file		File to encrypt
#
# returns	$file2		Encrypted file on success
# 				Empty string on non encrypted file/no CryptType chosen

sub encrypt_wrap($$) {
	my($dir_prf) = shift;
	my($file) = shift;
	my($file2) = "";

	if($dir_prf->{CryptType} eq "PGP") {
		$file2 = $file.".asc";

		my($identity,$recipient) = split(/,/, $dir_prf->{CryptData});
		myprint(P_INFO, "Encrypting $file with $dir_prf->{CryptType}/$recipient\n");
		my($gpg) = new Crypt::GPG;
		$gpg->gpgbin('/usr/bin/gpg');
		$gpg->secretkey($identity);
		$gpg->encryptsafe(0);
		$gpg->debug($dir_prf->{Debug});

		open(IN, "< $dir_prf->{LocalDir}/$file")
			or (myprint(P_ERROR, "Can't open file $file for reading: $!\n") and die);
		my($cleartext) = join('', <IN>);
		close(IN);
		open(OUT, "> $dir_prf->{LocalDir}/$file2")
			or (myprint(P_ERROR, "Can't open file $file2 for writing: $!\n") and die);
		foreach my $line ($gpg->encrypt($cleartext, $recipient, -sign)) {
			print OUT $line."\n";
		}
		close(OUT);
	}

	return $file2;
}

########################################################################################################
# Main
########################################################################################################

sub main($) {
	my(@argv) = @{(shift)};
	my($prog,$path) = get_progpath();
	my($test) = 0;

	if($#argv < 0 || $#argv > 1 || ($#argv == 0 && $argv[0] eq "--test")) {
		myprint(P_ERROR, "usage: $prog [--test] path_to_sndrcv.ini\n") and die;
	}

	if($argv[0] eq "--test") {
		$test = 1;
		shift @argv;
	}

	my($config) = get_config($argv[0]);

	my($date) = get_date();

	for my $key (keys %{$config}) {
		$verbosity = $config->{$key}->{Verbosity};
		if($config->{$key}->{LogFile} ne "") {
			open(SAVEOUT, ">&STDOUT");
			open(SAVEERR, ">&STDERR");
			open(STDOUT, ">> $config->{$key}->{LogFile}")
				or (myprint(P_ERROR, "Can't open Log File $config->{$key}->{LogFile}: $!\n") and die);
			open(STDERR, ">&STDOUT");
		}

		if($config->{$key}->{Active} eq "1" or $test == 1) {
			my($conn) = connect_wrap($config->{$key});
	
			if(download_loop($config->{$key}, $conn, $date) != 0) {
				myprint(P_ERROR, "Error in download loop!\n") and die;
			}
	
			if(upload_loop($config->{$key}, $conn, $date) != 0) {
				myprint(P_ERROR, "Error in upload loop!\n") and die;
			}

			disconnect_wrap($config->{$key}, $conn);
		} else {
			myprint(P_INFO, "Connection profile $key is Inactive.\n");
		}

		if($config->{$key}->{LogFile} ne "") {
			close(STDOUT);
			open(STDOUT, ">&SAVEOUT");
			open(STDERR, ">&SAVEERR");
		}
	}

	exit 0;
	close(SAVEOUT);
	close(SAVEERR);
}

main(\@ARGV);
