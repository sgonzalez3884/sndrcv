#!/usr/bin/perl -w

# TODO: Add 'min_time_between_connect' option to limit how often to connect to remote site to check for downloads
#       This will require writing to a 'lastconnect' file for each connection (In connect_wrap, ideally)
# TODO: Add 'stateful' option to track and not re-down/upload already down/uploaded files (MSPCMS, Aetna)
# TODO: Add LIST regex option for cases where NLST doesn't work (Aetna)
# TODO: Add wildcard for ARCHIVEDIR that expands to ARCHIVEDIR, to simplfy archivedir setup
# TODO: Add post-processing for zipfiles
# TODO: Formalize post-processing (download) and pre-processing (upload) configuration?

use strict;
use warnings;

use constant {
	PROG	=> 'sndrcv',
	VER	=> 20111028001
};

use constant SFTP_MODULE => 'Net::SFTP';
use Net::SFTP;	# Re-Enable Net::SFTP, Net::SFTP::Foreign has problems when sending files, does not allow password-interactive
use Math::BigInt::GMP; # Fast math library used by Net::SFTP
use Net::SFTP::Foreign;
use Net::FTP;
use WWW::Curl::Easy;
use Crypt::GPG;

use Mail::Sendmail;
use Email::Valid;
use File::Copy;
use File::Path;
use File::Basename;
use Data::Dumper;
use Config::General;
use POSIX qw{ strftime };
use Cwd qw{ abs_path };

########################################################################################################
# Constants
########################################################################################################

use constant P_ERROR	=> -1;
use constant P_PROG	=>  1;
use constant P_INFO	=>  2;
use constant P_DEBUG	=>  3;
use constant P_DEBUG1	=>  3;
use constant P_DEBUG2	=>  4;
use constant P_DEBUG3	=>  5;
use constant P_DEBUG4	=>  6;
use constant P_DEBUG5	=>  7;

########################################################################################################
# Globals
########################################################################################################

my($fh);			# Text output filehandle
my($verbosity) = P_PROG;	# Current verbosity level

########################################################################################################
# Subroutines
########################################################################################################

# myprint()		Conditionally print messages based on the current verbosity, and message level
#
# input parms		$level	Passed message severity level
# 			@_	Variable lenght argument list parseable by printf
#
# returns		none

sub myprint(@)
{
	my($level) = shift;

	if($verbosity >= $level) {
		printf(strftime("%b %d %T ", localtime));
		printf(@_);
	}
}

# get_progpath()	Detect the current running script's path & name
#
# input parms	none
#
# returns	$prog	The current running script's name
# 		$path	The current running script's path

sub get_progpath() {
	if($0 =~ m#^[^/]#) {
		return fileparse(abs_path(abs_path(".") . '/' . $0));
	} else {
		return fileparse($0);
	}
}

# validate_config()	Check current config for correctness & completeness
#
# input parms	\%config	Configuration values
#
# returns	none

sub validate_config($) {

	my($config) = shift;

	myprint(P_DEBUG5, "Read configuration as:\n");
	myprint(P_DEBUG5, Dumper($config));

	# Connection level loop
	foreach my $conn (sort(keys %{$config})) {

		# Set to unconnected
		$config->{$conn}->{ConnObj} = undef;

		# Required fields
		foreach my $fld ("Server", "ConnType") {
			if(!defined($config->{$conn}->{$fld}) || $config->{$conn}->{$fld} eq "") {
				myprint(P_ERROR, "Missing required field $fld in Connection $conn!\n") and die;
			}
		}

		# Set default values
		foreach my $fldval (
			["Port", "0"],
			["User", ""],
			["AuthType", "Password"],
			["AuthData", ""],
			["Verbosity", P_INFO],
			["LogFile", ""],
			["EmailList", ""],
			["Active", "0"]) {

			if(!defined($config->{$conn}->{$fldval->[0]}) || $config->{$conn}->{$fldval->[0]} eq "") {
				$config->{$conn}->{$fldval->[0]} = $fldval->[1];
			}
		}
		if($config->{$conn}->{Verbosity} >= P_DEBUG) {
			$config->{$conn}->{Debug} = 1;
		} else {
			$config->{$conn}->{Debug} = 0;
		}

		# Check set values
		if((grep $config->{$conn}->{ConnType},("ftp","ftps","ftpes","sftp")) == 0) {
			myprint(P_ERROR, "Invalid ConnType '$config->{$conn}->{ConnType}' in Connection $conn\n") and die;
		}

		if(!($config->{$conn}->{Port} =~ m/^[0-9]+$/)) {
			myprint(P_ERROR, "Invalid Port '$config->{$conn}->{Port}' in Connection $conn (must be non-negative integer)\n") and die;
		}

		if($config->{$conn}->{ConnType} eq 'ftps' and $config->{$conn}->{Port} != 0) {
			myprint(P_ERROR, "Port option not allowed when using ftps!\n") and die;
		}

		if($config->{$conn}->{AuthType} eq "Identity" &&
			$config->{$conn}->{ConnType} ne "sftp") {
			myprint(P_ERROR, "AuthType '$config->{$conn}->{AuthType}' specified for non sftp Connection $conn\n") and die;
		}

		if(!($config->{$conn}->{Verbosity} =~ /^(-1)|([1234567])$/)) {
			myprint(P_ERROR, "Unknown Verbosity flag '$config->{$conn}->{Verbosity}' specified in Connection $conn\n") and die;
		}

		my($emailok) = 1;
		my($emailcount) = 0;
		foreach my $email (split(/,/, $config->{$conn}->{EmailList})) {
			if(not Email::Valid->address($email)) {
				myprint(P_ERROR, "Invalid E-Mail '$email' specified in Connection $conn\n");
				$emailok = 0;
			}
			$emailcount++;
		}
		die if($emailok == 0);
		if($emailcount == 1) {
			myprint(P_ERROR, "Either 0 or at least 2 E-Mails must be specified for EmailList in Connection $conn\n") and die;
		}

		if(!($config->{$conn}->{Active} =~ /^[01]$/)) {
			myprint(P_ERROR, "Unknown Active flag '$config->{$conn}->{Active}' specified in Connection $conn\n") and die;
		}

		if(defined($config->{$conn}->{Download})) {
			# Download level loop
			foreach my $prf (sort(keys %{$config->{$conn}->{Download}})) {
				# Required fields
				foreach my $fld ("RemoteDir", "Regex", "LocalDir", "TempDir") {
					if(!defined($config->{$conn}->{Download}->{$prf}->{$fld}) ||
						$config->{$conn}->{Download}->{$prf}->{$fld} eq "") {
						myprint(P_ERROR, "Missing required field $fld in Download profile $prf, Connection $conn!\n") and die;
					}
				}

				# Set default values
				foreach my $fldval (
					["ArchiveDir", ""],
					["ArchivePst", ""],
					["CryptType", "None"],
					["CryptData", ""],
					["TransferType","BINARY"],
					["MakeList", "0"],
					["ListName", ""],
					["EmailNotify", "0"],
					["Delete", "1"],
					["Active", "0"],
					["Debug", "0"]) {

					if(!defined($config->{$conn}->{Download}->{$prf}->{$fldval->[0]}) ||
						$config->{$conn}->{Download}->{$prf}->{$fldval->[0]} eq "") {
						$config->{$conn}->{Download}->{$prf}->{$fldval->[0]} = $fldval->[1];
					}
				}

				# Check set values
				if((grep $config->{$conn}->{Download}->{$prf}->{CryptType},("PGP","None")) == 0) {
					myprint(P_ERROR, "Unknown CryptType '$config->{$conn}->{Download}->{$prf}->{CryptType}' in Download profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{Download}->{$prf}->{CryptType} eq "PGP" and
					$config->{$conn}->{Download}->{$prf}->{CryptData} eq "") {
					myprint(P_ERROR, "CryptType '$config->{$conn}->{Download}->{$prf}->{CryptType}' requires CryptData in Download profile $prf, Connection $conn\n") and die;
				}
				if((grep $config->{$conn}->{Download}->{$prf}->{TransferType},("BINARY","ASCII")) == 0) {
					myprint(P_ERROR, "Unknown TransferType flag '$config->{$conn}->{Download}->{$prf}->{Transfertype}' in Download profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Download}->{$prf}->{MakeList} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown MakeList flag '$config->{$conn}->{Download}->{$prf}->{MakeList}' in Download profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Download}->{$prf}->{EmailNotify} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown EmailNotify flag '$config->{$conn}->{Download}->{$prf}->{EmailNotify}' in Download profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{EmailList} eq "" and $config->{$conn}->{Download}->{$prf}->{EmailNotify} == 1) {
					myprint(P_ERROR, "EmailNotify flag set with no EmailList in Download profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Download}->{$prf}->{Debug} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown Debug flag '$config->{$conn}->{Download}->{$prf}->{Debug}' in Download profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{Download}->{$prf}->{MakeList} == 1 and
					$config->{$conn}->{Download}->{$prf}->{ListName} eq "") {
					$config->{$conn}->{Download}->{$prf}->{ListName} = $prf.".lst";
				}
			}
		}

		if(defined($config->{$conn}->{Upload})) {
			# Upload level loop
			foreach my $prf (sort(keys %{$config->{$conn}->{Upload}})) {
				# Required fields
				foreach my $fld ("RemoteDir", "Regex", "LocalDir", "TempDir") {
					if(!defined($config->{$conn}->{Upload}->{$prf}->{$fld}) ||
						$config->{$conn}->{Upload}->{$prf}->{$fld} eq "") {
						myprint(P_ERROR, "Missing required field $fld in Upload profile $prf, Connection $conn!\n") and die;
					}
				}

				# Set default values
				foreach my $fldval (
					["ArchiveDir", ""],
					["ArchivePst", ""],
					["CryptType", "None"],
					["CryptData", ""],
					["TransferType","BINARY"],
					["EmailNotify", "0"],
					["Active", "0"],
					["Debug", "0"]) {

					if(!defined($config->{$conn}->{Upload}->{$prf}->{$fldval->[0]}) ||
						$config->{$conn}->{Upload}->{$prf}->{$fldval->[0]} eq "") {
						$config->{$conn}->{Upload}->{$prf}->{$fldval->[0]} = $fldval->[1];
					}
				}

				# Check set values
				if((grep $config->{$conn}->{Upload}->{$prf}->{CryptType},("PGP","None")) == 0) {
					myprint(P_ERROR, "Unknown CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' in Upload profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{Upload}->{$prf}->{CryptType} eq "PGP") {
					if($config->{$conn}->{Upload}->{$prf}->{CryptData} eq "") {
						myprint(P_ERROR, "CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' requires CryptData in Upload profile $prf, Connection $conn\n") and die;
					} elsif(!($config->{$conn}->{Upload}->{$prf}->{CryptData}) =~ m/^[^,]+,[^,]+$/) {
						myprint(P_ERROR, "CryptType '$config->{$conn}->{Upload}->{$prf}->{CryptType}' requires 2 items in CryptData in Upload profile $prf, Connection $conn\n") and die;
					}

				}
				if((grep $config->{$conn}->{Upload}->{$prf}->{TransferType},("BINARY","ASCII")) == 0) {
					myprint(P_ERROR, "Unknown TransferType flag '$config->{$conn}->{Upload}->{$prf}->{Transfertype}' in Upload profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Upload}->{$prf}->{EmailNotify} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown EmailNotify flag '$config->{$conn}->{Upload}->{$prf}->{EmailNotify}' in Upload profile $prf, Connection $conn\n") and die;
				}
				if($config->{$conn}->{EmailList} eq "" and $config->{$conn}->{Upload}->{$prf}->{EmailNotify} == 1) {
					myprint(P_ERROR, "EmailNotify flag set with no EmailList in Upload profile $prf, Connection $conn\n") and die;
				}
				if(!($config->{$conn}->{Upload}->{$prf}->{Debug} =~ /^[01]$/)) {
					myprint(P_ERROR, "Unknown Debug flag '$config->{$conn}->{Upload}->{$prf}->{Debug}' in Upload profile $prf, Connection $conn\n") and die;
				}
			}
		}

		# Determine Port value when set to Auto
		if($config->{$conn}->{Port} == 0) {
			if($config->{$conn}->{ConnType} eq "ftp") {
				$config->{$conn}->{Port} = 21;
			} elsif($config->{$conn}->{ConnType} eq "ftps") {
				$config->{$conn}->{Port} = 990;
			} elsif($config->{$conn}->{ConnType} eq "ftpes") {
				$config->{$conn}->{Port} = 21;
			} elsif($config->{$conn}->{ConnType} eq "sftp") {
				$config->{$conn}->{Port} = 22;
			}
		}

	}

	myprint(P_DEBUG5, "Cleaned configuration:\n");
	myprint(P_DEBUG5, Dumper($config));
}

# get_config()	Uses Config::General to parse a config file into a %hash
#
# input parms	$config_path	Path to config
#
# returns	\%config	Configuration values

sub get_config($) {

	my($config_path) = shift;
	my($config_obj) = new Config::General($config_path);
	my($type, $config) = $config_obj->getall;

	validate_config($config);

	return $config;

}

# get_date()	Returns an array of values corresponding to time( now );
#
# input parms	None
#
# returns	\@date	Values corresponding to time( now );

sub get_date() {

	my(@date) = localtime(time);

	$date[0] = sprintf("%02d", $date[0]);		# %s%  Second
	$date[1] = sprintf("%02d", $date[1]);		# %m%  Minute
	$date[2] = sprintf("%02d", $date[2]);		# %h%  Hour
	$date[3] = sprintf("%02d", $date[3]);		# %D%  day of Month
	$date[4] = sprintf("%02d", ($date[4] + 1));	# %M%  Month
	$date[5] = sprintf("%04d", ($date[5] + 1900));	# %CY% Year 4-Dig
	$date[7] = sprintf("%03d", ($date[7] + 1));	# %J%  Day of Year
	$date[9] = substr($date[5],1,2);		# %C%  Century
	$date[10] = substr($date[5],3,2);		# %Y%  Year 2-Dig

	return \@date;

}

# get_filesize()	Returns a human-readable string of the specified file's size with unit
#
# input parms	full path to file
#
# returns	human-readable string of the specified file's size with unit

sub get_filesize($) {

	my($filename) = shift;
	my($size) = (-s $filename);

	my(@units) = ('B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB');

	my($i) = 0;
	while($size >= 1024) {
		$size /= 1024;
		$i++;
	}

	die "Overflow on get_filesize($filename)" if($#units < $i);
	my($ret) = sprintf("%0.2f", $size);
	$ret =~ s/0*$//;
	$ret =~ s/\.$//;
	$ret = $ret . ' ' . $units[$i];

	return($ret);

}

# var_replace()	Replace wildcard values in a string with current date values
#
# Wildcards replaced:
# %s%	Current Second		00-59 (60 on leap-second)
# %m%	Current Minute		00-59
# %h%	Current Hour		00-23
# %M%	Current Month		00-12
# %D%	Current Day of Month	00-31
# %CY%	Current 4-Dig Year	CCYY
# %C%	Current 2-Dig Century	CC
# %Y%	Current 2-Dig Year	YY
# %J%	Current Day of Year	001-366
#
# input parms	$str	String to operate on
# 		\@date	Date values to use for replacement
#
# returns	$str	modified string

sub var_replace($$) {
	my($str) = shift;
	my(@date) = @{(shift)};

	$str =~ s/[%]s[%]/$date[0]/g;
	$str =~ s/[%]m[%]/$date[1]/g;
	$str =~ s/[%]h[%]/$date[2]/g;
	$str =~ s/[%]D[%]/$date[3]/g;
	$str =~ s/[%]M[%]/$date[4]/g;
	$str =~ s/[%]CY[%]/$date[5]/g;
	$str =~ s/[%]J[%]/$date[7]/g;
	$str =~ s/[%]C[%]/$date[9]/g;
	$str =~ s/[%]Y[%]/$date[10]/g;

	return $str;
}

# download_loop()	Loop through download directory profiles, downloading whatever matches
#
# input parms		\%conn_prf	Connection Profile configuration values
# 			\@date		Current date
# 			\%email_data	Hash of Email Notification Data
#
# returns		0 on success
# 			1 on general failure

sub download_loop($$$) {
	my($conn_prf) = shift;
	my($date) = shift;
	my($email_data) = shift;

	foreach my $key (keys %{$conn_prf->{Download}}) {
		connect_wrap($conn_prf);
		my($dir) = $conn_prf->{Download}->{$key};

		if($dir->{Active} eq "0") {
			myprint(P_INFO, "Download profile $key is Inactive.\n");
			next;
		}

		# Replace %Variables%
		$dir->{LocalDir} = var_replace($dir->{LocalDir}, $date);
		$dir->{RemoteDir} = var_replace($dir->{RemoteDir}, $date);
		$dir->{ArchiveDir} = var_replace($dir->{ArchiveDir}, $date);
		$dir->{ArchivePst} = var_replace($dir->{ArchivePst}, $date);

		mkpath($dir->{LocalDir});
		if($dir->{ArchiveDir} ne "") {
			mkpath($dir->{ArchiveDir});
		}
		mkpath($dir->{TempDir});
		chdir($dir->{TempDir});

		myprint(P_INFO, "Getting file list for '$dir->{RemoteDir}'.\n");
		my(@list) = grep { $_ =~ m/$dir->{Regex}/i } ls_wrap($conn_prf, $dir->{RemoteDir});

		if($#list >= 0) {
			myprint(P_PROG, "Downloading all files matching /$dir->{Regex}/i in '$dir->{RemoteDir}'.\n");
			foreach my $file (@list) {
				myprint(P_INFO, "Receiving '$file'...\n");
				get_wrap($conn_prf, $file, $dir->{RemoteDir}, $dir->{TransferType});

				my($size) = get_filesize($dir->{TempDir} . '/' . $file);

				my($file2) = decrypt_wrap($dir, $file);

				if($dir->{Debug} eq "0") {

					# Swap file & file2 data
					if($file2 ne "") {
						my($file3) = $file;
						$file = $file2;
						$file2 = $file3;

					}
					# file = Decypted file if encrypted, otherwise downloaded file
					# file2 = Downloaded file if encrypted

					myprint(P_INFO, "Copying file '$file' to '$dir->{LocalDir}'...\n");
					copy($dir->{TempDir} . '/' . $file, $dir->{LocalDir} . '/')
						or (myprint(P_ERROR, "$!\n") and die);

					foreach my $arcfile ($file, $file2) {
						if($arcfile ne "") {
							if($dir->{ArchiveDir} ne "") {
								my($newfile) = $arcfile;
								if($newfile =~ m/^(.*)([.][^.]*)$/) {
									$newfile = $1 . $dir->{ArchivePst} . $2;
								} else {
									$newfile .= $dir->{ArchivePst};
								}
								myprint(P_INFO, "Moving file '$arcfile' to '$dir->{ArchiveDir}/$newfile'...\n");
								move($dir->{TempDir} . '/' . $arcfile, $dir->{ArchiveDir} . '/' . $newfile)
									or (myprint(P_ERROR, "$!\n") and die);
							} else {
								unlink($dir->{TempDir} . '/' . $arcfile);
							}
						}
					}
				}

				if($dir->{Debug} eq "0" and $dir->{Delete} eq "1") {
					if($file2 ne "") {
						myprint(P_INFO, "Removing file '$file2' from server '$conn_prf->{Server}'...\n");
						rm_wrap($conn_prf, $file2, $dir->{RemoteDir});
					} else {
						myprint(P_INFO, "Removing file '$file' from server '$conn_prf->{Server}'...\n");
						rm_wrap($conn_prf, $file, $dir->{RemoteDir});
					}

				}

				push(@{ $email_data->{Message} }, ['D',$dir->{RemoteDir},$file,$size]);
			}
		} else {
			myprint(P_PROG, "No files matching /$dir->{Regex}/i in '$dir->{RemoteDir}'.\n");
		}

		if($dir->{MakeList} eq "1") {
			myprint(P_INFO, "Creating new file list '".$dir->{ListName}."'\n");

			my(@list) = grep { $_ =~ m/$dir->{Regex}/i } lls_wrap($dir->{LocalDir});
			if($#list >= 0) {
				open(OUT, "> " . $dir->{TempDir} . "/" . $dir->{ListName})
						or (myprint(P_ERROR, "Can't open file '" . $dir->{TempDir} . "/" . $dir->{ListName} . "' for writing: $!\n") and
						die);
				foreach my $file (@list) {
					if($file =~ m/$dir->{Regex}/i) {
						print OUT "$file\n";
					}
				}
				close(OUT);

				if($dir->{Debug} eq "0") {
					myprint(P_INFO, "Moving file '".$dir->{ListName}."' to '$dir->{LocalDir}'...\n");
					move($dir->{TempDir} . '/' . $dir->{ListName}, $dir->{LocalDir} . '/')
						or (myprint(P_ERROR, "$!\n") and die);
				}
			}
		}
	}

	# FIXME: Do we need to actually do error checking?
	return 0;

}

# upload_loop()		Loop through upload directory profiles, uploading whatever matches
#
# input parms		\%conn_prf	Connection Profile configuration values
# 			\@date		Current date
# 			\%email_data	Hash of Email Notification Data
#
# returns		0 on success
# 			1 on general failure

sub upload_loop($$$) {
	my($conn_prf) = shift;
	my($date) = shift;
	my($email_data) = shift;

	return if (!defined($conn_prf->{Upload}));

	foreach my $key (keys %{$conn_prf->{Upload}}) {
		my($dir) = $conn_prf->{Upload}->{$key};

		if($dir->{Active} eq "0") {
			myprint(P_INFO, "Upload profile $key is Inactive.\n");
			next;
		}

		# Replace %Variables%
		$dir->{LocalDir} = var_replace($dir->{LocalDir}, $date);
		$dir->{RemoteDir} = var_replace($dir->{RemoteDir}, $date);
		$dir->{RemoteFile} = var_replace($dir->{RemoteFile}, $date);
		$dir->{ArchiveDir} = var_replace($dir->{ArchiveDir}, $date);
		$dir->{ArchivePst} = var_replace($dir->{ArchivePst}, $date);

		mkpath($dir->{LocalDir});
		if($dir->{ArchiveDir} ne "") {
			mkpath($dir->{ArchiveDir});
		}
		mkpath($dir->{TempDir});
		chdir($dir->{TempDir});

		myprint(P_INFO, "Getting file list for '$dir->{LocalDir}'.\n");
		my(@list) = ();
		foreach my $file (lls_wrap($dir->{LocalDir})) {
			if ( -f $dir->{LocalDir} . "/" . $file and
					$file =~ m/$dir->{Regex}/i) {
				my($rfile) = $file;

				$rfile = eval(eval($dir->{RemoteFile})) if (defined($dir->{RemoteFile}) and
					$dir->{RemoteFile} ne '' and
					$dir->{RemoteFile} ne '""');

				myprint(P_DEBUG5, "Local file: '$file' maps to Remote file: '$rfile'\n");
				push(@list, [$file, $rfile]);
				
			}
		}
		#my(@list) = grep { -f $dir->{LocalDir} . "/" . $_ && m/$dir->{Regex}/i } lls_wrap($dir->{LocalDir});
		#opendir(DIR, $dir->{LocalDir})
		#	or (myprint(P_ERROR, "Can't open directory '$dir->{LocalDir}': $!\n") and die);
		#my(@list) = grep { -f $dir->{LocalDir} . "/" . $_ && /$dir->{Regex}/i } readdir(DIR);
		#closedir(DIR);

		if($#list >= 0) {
			myprint(P_PROG, "Uploading all files matching /$dir->{Regex}/i in '$dir->{LocalDir}'.\n");
			foreach my $filearr (@list) {
				my($file, $rfile) = @$filearr;
				my($file2) = encrypt_wrap($dir, $file);

				# Swap file & file2 data
				if($file2 ne "") {
					my($file3) = $file;
					$file = $file2;
					$file2 = $file3;
				}
				# file = Encrypted file if encrypted, otherwise file
				# file2 = Original file if encrypted

				my($size) = get_filesize($dir->{LocalDir} . '/' . $file);

				if ($file eq $rfile) {
					myprint(P_INFO, "Sending '$file'...\n");
				} else {
					myprint(P_INFO, "Sending '$file' as '$rfile'...\n");
				}
				put_wrap($conn_prf, $file, $rfile, $dir->{LocalDir}, $dir->{RemoteDir}, $dir->{TransferType});

				if($dir->{Debug} eq "0") {
					foreach my $arcfile ($file, $file2) {
						if($arcfile ne "") {
							if($dir->{ArchiveDir} ne "") {
								my($newfile) = $arcfile;
								if($newfile =~ m/^(.*)([.][^.]*)$/) {
									$newfile = $1 . $dir->{ArchivePst} . $2;
								} else {
									$newfile .= $dir->{ArchivePst};
								}

								myprint(P_INFO, "Moving file '$arcfile' to '$dir->{ArchiveDir}/$newfile'...\n");
								move($dir->{LocalDir} . '/' . $arcfile, $dir->{ArchiveDir} . '/' . $newfile)
									or (myprint(P_ERROR, "$!\n") and die);
							} else {
								unlink($dir->{LocalDir} . '/' . $arcfile);
							}
						}
					}
				}

				push(@{ $email_data->{Message} }, ['U',$dir->{RemoteDir},$file,$size]);
			}

		} else {
			myprint(P_PROG, "No files matching /$dir->{Regex}/i in '$dir->{LocalDir}'.\n");
		}
	}

	# FIXME: Do we need to actually do error checking?
	return 0;

}

# send_email()		Parse E-Mail Hash and send E-Mail
#
# input parms		\%conn_prf	Connection Profile configuration values
# 			\%email_data	Hash of Email Notification Data
#
# returns		0 on success
# 			1 on general failure
sub send_email($$) {
	my($conn_prf) = shift;
	my($email) = shift;

	my(@xfrlog);
	@xfrlog = sort {
		$a->[0] cmp $b->[0] ||
		$a->[1] cmp $b->[1] ||
		$a->[2] cmp $b->[2]
	} @{ $email->{Message} };

	if($#xfrlog == -1) {
		return 0;
	}

	$email->{Message} = "The following file transfers have completed on " .
		$conn_prf->{ConnType} . "://" .
		$conn_prf->{User} . '@' . $conn_prf->{Server} . ':' .
		$conn_prf->{Port} . "\n";

	my($type_l, $dir_l) = ('','');

	foreach my $xfr (@xfrlog) {
		if($$xfr[0] ne $type_l) {
			if($$xfr[0] eq 'D') {
				$email->{Message} .= "\nDownloads:";
			}
			elsif($$xfr[0] eq 'U') {
				$email->{Message} .= "\nUploads:";
			}
			$type_l = $$xfr[0];
		}
		if($$xfr[1] ne $dir_l) {
			$email->{Message} .= "\n  Dir: $$xfr[1]\n";
			$dir_l = $$xfr[1];
		}

		$email->{Message} .= "    $$xfr[2] ($$xfr[3])\n";

	}

	myprint(P_INFO, "Sending E-Mail Notification from $email->{From} to $email->{To}.\n");

	if(!sendmail(%{ $email })) {
		myprint(P_DEBUG, "Error sending Notification E-Mail: ".$Mail::Sendmail::error."\n") and die;
	}
}

########################################################################################################
# Wrapper Subroutines
########################################################################################################

# curl_wrap()	Wrapper for curl->perform retries 'unknown PASV reply (13)' errors
#
# input parms	$conn_prf	Connection Configuration
#
# returns	$retval		Retun value from perform

sub curl_wrap($) {
	my($conn_prf) = shift;
	my($retval);
	my($retry_max) = 5;
	
	for(my($retry) = 1; $retry <= ($retry_max+1); $retry++) {
		$retval = $conn_prf->{ConnObj}->perform;

		# Return if no error, or error is not 'unknown PASV reply (99)'
		if($retval == 0 or $retval != 13) {
			return $retval;
		}
		sleep 1; # Curl runs better if we sleep in-between performs?
		myprint(P_DEBUG, "Recieved ".$conn_prf->{ConnObj}->strerror($retval)." ($retval). Retry attempt $retry of $retry_max\n");
	}

	return $retval;
}

# connect_wrap()	Connects to specified server
#
# input parms	\%conn_prf	Connection Profile configuration values
#
# returns	$conn		Connection object

sub connect_wrap($) {
	my($conn_prf) = shift;

	return $conn_prf->{ConnObj} if (defined($conn_prf->{ConnObj}));

	if($conn_prf->{ConnType} eq "sftp") {
		if(SFTP_MODULE eq 'Net::SFTP::Foreign') {
			if($conn_prf->{AuthType} eq "Password") {
				myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using PASSWORD...\n");
				if($conn_prf->{Debug} eq "1") {
					$conn_prf->{ConnObj} = Net::SFTP::Foreign->new(
							$conn_prf->{Server},
							user => $conn_prf->{User},
							password => $conn_prf->{AuthData},
							port => $conn_prf->{Port},
							more => [ '-v' ]
						) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
				} else {
					$conn_prf->{ConnObj} = Net::SFTP::Foreign->new(
							$conn_prf->{Server},
							user => $conn_prf->{User},
							password => $conn_prf->{AuthData},
							port => $conn_prf->{Port}
						) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
				}
			} else {
				myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using IDENTITY...\n");
				if($conn_prf->{Debug} eq "1") {
					$conn_prf->{ConnObj} = Net::SFTP::Foreign->new(
							$conn_prf->{Server},
							user => $conn_prf->{User},
							password => $conn_prf->{AuthData},
							port => $conn_prf->{Port},
							more => [
								'-i' => $conn_prf->{AuthData},
								'-v'
							]
						) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
				} else {
					$conn_prf->{ConnObj} = Net::SFTP::Foreign->new(
							$conn_prf->{Server},
							user => $conn_prf->{User},
							password => $conn_prf->{AuthData},
							port => $conn_prf->{Port},
							more => [
								'-i' => $conn_prf->{AuthData}
							]
						) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
				}
			}
		} else { # Net::SFTP
			if($conn_prf->{AuthType} eq "Password") {
				myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using PASSWORD...\n");
				$conn_prf->{ConnObj} = Net::SFTP->new(
						$conn_prf->{Server},
						user => $conn_prf->{User}, 
						password => $conn_prf->{AuthData},
						debug => $conn_prf->{Debug},
						ssh_args => [
							port => $conn_prf->{Port}
						]
					) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
			} else {
				myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using IDENTITY...\n");
				$conn_prf->{ConnObj} = Net::SFTP->new(
						$conn_prf->{Server},
						user => $conn_prf->{User}, 
						debug => $conn_prf->{Debug},
						ssh_args => [ 
							identity_files => [ $conn_prf->{AuthData} ],
							port => $conn_prf->{Port}
						]
					) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
			}
		}
	} elsif($conn_prf->{ConnType} eq "ftp") {
		myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using PASSWORD...\n");
		$conn_prf->{ConnObj} = Net::FTP->new(
				$conn_prf->{Server},
				Debug => $conn_prf->{Debug},
				Port => $conn_prf->{Port}
			) or (myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: $!\n") and die);
		$conn_prf->{ConnObj}->login($conn_prf->{User}, $conn_prf->{AuthData})
			or (myprint(P_ERROR, "Cannot login to $conn_prf->{Server}: %s\n", $conn_prf->{ConnObj}->message) and die);
	} elsif($conn_prf->{ConnType} eq "ftps") {
		myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using PASSWORD...\n");
		$conn_prf->{ConnObj} = new WWW::Curl::Easy;
		$conn_prf->{ConnObj}->setopt(CURLOPT_SSL_VERIFYPEER,0);
		$conn_prf->{ConnObj}->setopt(CURLOPT_FTP_USE_EPSV,0);
		$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftps://'.$conn_prf->{Server});
		$conn_prf->{ConnObj}->setopt(CURLOPT_USERPWD,$conn_prf->{User}.':'.$conn_prf->{AuthData});
		$conn_prf->{ConnObj}->setopt(CURLOPT_VERBOSE,$conn_prf->{Debug});

		my($fileb);
		open($fileb, ">", "/dev/null");
		$conn_prf->{ConnObj}->setopt(CURLOPT_WRITEDATA,$fileb);
		my $retval = curl_wrap($conn_prf);
		close($fileb);
		myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: ".$conn_prf->{ConnObj}->strerror($retval)." ($retval)\n") and die if($retval != 0);
	} elsif($conn_prf->{ConnType} eq "ftpes") {
		myprint(P_PROG, "Logging in to server '$conn_prf->{Server}:$conn_prf->{Port}' as '$conn_prf->{User}' using PASSWORD...\n");
		$conn_prf->{ConnObj} = new WWW::Curl::Easy;
		$conn_prf->{ConnObj}->setopt(CURLOPT_FTP_SSL,1);
		$conn_prf->{ConnObj}->setopt(CURLOPT_FTP_SSL_CCC,1);
		$conn_prf->{ConnObj}->setopt(CURLOPT_SSL_VERIFYPEER,0);
		$conn_prf->{ConnObj}->setopt(CURLOPT_FTP_USE_EPSV,0);
		$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server});
		$conn_prf->{ConnObj}->setopt(CURLOPT_USERPWD,$conn_prf->{User}.':'.$conn_prf->{AuthData});
		$conn_prf->{ConnObj}->setopt(CURLOPT_VERBOSE,$conn_prf->{Debug});
		$conn_prf->{ConnObj}->setopt(CURLOPT_PORT,$conn_prf->{Port});

		my($fileb);
		open($fileb, ">", "/dev/null");
		$conn_prf->{ConnObj}->setopt(CURLOPT_WRITEDATA,$fileb);
		my $retval = curl_wrap($conn_prf);
		close($fileb);
		myprint(P_ERROR, "Cannot connect to $conn_prf->{Server}: ".$conn_prf->{ConnObj}->strerror($retval)." ($retval)\n") and die if($retval != 0);
	} else {
		myprint(P_ERROR, "Unknown ConnType $conn_prf->{ConnType}!\n") and die;
	}

	return $conn_prf->{ConnObj};

}

# disconnect_wrap()	Disconnects from specified server
#
# input parms	\%conn_prf	Connection Profile configuration values
#
# returns	none

sub disconnect_wrap($) {
	my($conn_prf) = shift;

	return if(!defined($conn_prf->{ConnObj}));

	myprint(P_PROG, "Disconnecting from server '$conn_prf->{Server}'...\n");
	if($conn_prf->{ConnType} eq "sftp") {
		undef $conn_prf->{ConnObj};
	} elsif($conn_prf->{ConnType} eq "ftp") {
		$conn_prf->{ConnObj}->quit;
	} elsif($conn_prf->{ConnType} eq "ftpes") {
		undef $conn_prf->{ConnObj};
	} elsif($conn_prf->{ConnType} eq "ftps") {
		undef $conn_prf->{ConnObj};
	} else {
		myprint(P_ERROR, "Unknown ConnType $conn_prf->{ConnType}!\n") and die;
	}
	
	$conn_prf->{ConnObj} = undef;

}

# lls_wrap()	Get file list for specified *LOCAL* directory
#
# input parms	$dir		Directory to list
#
# returns	@list	Directory Listing

sub lls_wrap($) {
	my($dir) = shift;
	return ls_wrap({ConnObj => 'LocalDir'}, $dir);

}

# ls_wrap()	Get file list for specified directory via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
# 		$dir		Directory to list
#
# returns	@list	Directory Listing

sub ls_wrap($$) {
	my($conn_prf) = shift;
	my($dir) = shift;
	my(@list) = ();
	
	connect_wrap($conn_prf);

	if($conn_prf->{ConnObj} =~ /^Net::SFTP::Foreign/) {
		foreach my $item (@{$conn_prf->{ConnObj}->ls($dir)}) {
			push @list, $item->{filename};
		}
	} elsif($conn_prf->{ConnObj} =~ /^Net::SFTP/) {
		foreach my $item ($conn_prf->{ConnObj}->ls($dir)) {
			push @list, $item->{filename};
		}
	} elsif($conn_prf->{ConnObj} =~ /^Net::FTP/) {
		foreach my $item ($conn_prf->{ConnObj}->ls($dir)) {
			$item =~ s|^$dir[/\\]*||;
			push @list, $item;
		}
	} elsif($conn_prf->{ConnObj} =~ /^WWW::Curl/) {
		if($conn_prf->{ConnType} eq 'ftpes') {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$dir.'/');
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftps://'.$conn_prf->{Server}.'/'.$dir.'/');
			$conn_prf->{ConnObj}->setopt(CURLOPT_FTPLISTONLY,1);
		}

		my($response_body) = "";
		open(my $fh, ">", \$response_body);
			$conn_prf->{ConnObj}->setopt(CURLOPT_WRITEDATA,$fh);
			my $retval = curl_wrap($conn_prf);
			myprint(P_ERROR, "Can't list directory $dir: ".$conn_prf->{ConnObj}->strerror($retval)."\n") and die if($retval != 0);
			$conn_prf->{ConnObj}->setopt(CURLOPT_FTPLISTONLY,0);
		close($fh);

		if(defined($response_body)) {
			myprint(P_DEBUG5, "Response body when listing FTPS directory $dir:\n$response_body\n");
			foreach my $line (split(/\n|\r/, $response_body)) {
					chomp($line);
					if($conn_prf->{ConnType} eq 'ftpes') {
						if(!($line =~ m/total\s*\d*$/)) {
							$line =~ s/^\s+//g;
							$line =~ s/\s+$//g;
							$line =~ s/^.*[A-Z][a-z]{2}\s{1,2}\d{1,2}\s+\d{1,2}:\d{2}\s+//;
							push(@list, $line) if($line ne "");
						}
					} else {
							push(@list, $line) if($line ne "");
					}
			}
			undef $response_body;
		} else {
			myprint(P_DEBUG5, "No response body when listing FTPS directory $dir\n");
		}
	} elsif($conn_prf->{ConnObj} =~ /^LocalDir/) {
		opendir(DIR, $dir)
			or (myprint(P_ERROR, "Can't open directory $dir: $!\n") and die);
		@list = readdir(DIR);
		closedir(DIR)
			or (myprint(P_ERROR, "Can't close directory $dir: $!\n") and die);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn_prf->{ConnObj}\n") and die;
	}

	myprint(P_DEBUG5, "List Entries (" . ($#list+1) . ")\n");
	foreach my $item (@list) {
		myprint(P_DEBUG5, "List Entry: '$item'\n");
	}
	return @list;

}

# get_wrap()	Get specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
# 		$file		File to get
# 		$dir		Directory file is located
# 		$type		Transfer Type
#
# returns			0 on success
# 				1 on general failure

sub get_wrap($$$$) {
	my($conn_prf) = shift;
	my($file) = shift;
	my($dir) = shift;
	my($type) = shift;

	connect_wrap($conn_prf);

	if($conn_prf->{ConnObj} =~ /^Net::SFTP::Foreign/) {
		$conn_prf->{ConnObj}->get($dir . '/' . $file, $file);
		if(! -e $file) {
			myprint(P_ERROR, "Error receiving '$file'\n") and die;
		}
	} elsif($conn_prf->{ConnObj} =~ /^Net::SFTP/) {
		$conn_prf->{ConnObj}->get($dir . '/' . $file, $file);
		if(! -e $file) {
			myprint(P_ERROR, "Error receiving '$file'\n") and die;
		}
	} elsif($conn_prf->{ConnObj} =~ /^Net::FTP/) {
		if($type eq "ASCII") {
			$conn_prf->{ConnObj}->ascii();
		} else {
			$conn_prf->{ConnObj}->binary();
		}

		$conn_prf->{ConnObj}->get($dir . '/' . $file, $file)
			or (myprint(P_ERROR, "Error receiving '$file'\n") and die);
	} elsif($conn_prf->{ConnObj} =~ /^WWW::Curl/) {
		if($type eq "ASCII") {
			$conn_prf->{ConnObj}->setopt(CURLOPT_TRANSFERTEXT,1);
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_TRANSFERTEXT,0);
		}
		
		if($conn_prf->{ConnType} eq 'ftpes') {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$dir.'/'.$file);
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftps://'.$conn_prf->{Server}.'/'.$dir.'/'.$file);
		}
		my($fileb);
		open($fileb, "> $file");
			$conn_prf->{ConnObj}->setopt(CURLOPT_WRITEDATA,$fileb);
			my $retval = curl_wrap($conn_prf);
			# FIXME: We get 'Transferred a partial file (18) when we upload/downloai with ASCII? ignore... for now.
			myprint(P_ERROR, "Error receiving '$file': ".$conn_prf->{ConnObj}->strerror($retval)." ($retval)\n") and
				die if(($retval != 0 and $type eq "BINARY") or ($retval != 0 and $retval != 18 and $type eq "ASCII"));
		close($fileb);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn_prf->{ConnObj}\n") and die;
	}

	return 0;

}

# put_wrap()	Put specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
# 		$file		Local file to put
# 		$rfile		Remote file name
# 		$dir		Directory file is located
# 		$rmt_dir	Remote directory to put file
# 		$type		Transfer Type
#
# returns			0 on success
# 				1 on general failure

sub put_wrap($$$$$$) {
	my($conn_prf) = shift;
	my($file) = shift;
	my($rfile) = shift;
	my($dir) = shift;
	my($rmt_dir) = shift;
	my($type) = shift;

	connect_wrap($conn_prf);

	if($conn_prf->{ConnObj} =~ /^Net::SFTP::Foreign/) {
		$conn_prf->{ConnObj}->put($dir . '/' . $file, $rmt_dir . '/' . $rfile,
				copy_perms => 0, copy_time => 0)
			or (myprint(P_ERROR, "Error sending '$file': " . $conn_prf->{ConnObj}->error . " (" . $conn_prf->{ConnObj}->status . ")\n") and die);
	} elsif($conn_prf->{ConnObj} =~ /^Net::SFTP/) {
		$conn_prf->{ConnObj}->put($dir . '/' . $file, $rmt_dir . '/' . $rfile)
			or (myprint(P_ERROR, "Error sending '$file'\n") and die);
	} elsif($conn_prf->{ConnObj} =~ /^Net::FTP/) {
		if($type eq "ASCII") {
			$conn_prf->{ConnObj}->ascii();
		} else {
			$conn_prf->{ConnObj}->binary();
		}

		$conn_prf->{ConnObj}->put($dir . '/' . $file, $rmt_dir . '/' . $rfile)
			or (myprint(P_ERROR, "Error sending '$file'\n") and die);
	} elsif($conn_prf->{ConnObj} =~ /^WWW::Curl/) {
		if($type eq "ASCII") {
			$conn_prf->{ConnObj}->setopt(CURLOPT_TRANSFERTEXT,1);
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_TRANSFERTEXT,0);
		}
		if($conn_prf->{ConnType} eq 'ftpes') {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/'.$rmt_dir.'/'.$rfile);
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftps://'.$conn_prf->{Server}.'/'.$rmt_dir.'/'.$rfile);
		}
		$conn_prf->{ConnObj}->setopt(CURLOPT_UPLOAD,1);
		my($fileb);
 		open($fileb, "< $dir/$file");
			$conn_prf->{ConnObj}->setopt(CURLOPT_INFILE,$fileb);
			my $retval = curl_wrap($conn_prf);
			# FIXME: We get 'Transferred a partial file (18) when we upload/downloai with ASCII? ignore... for now.
			myprint(P_ERROR, "Error sending '$file': ".$conn_prf->{ConnObj}->strerror($retval)." ($retval)\n") and
				die if(($retval != 0 and $type eq "BINARY") or ($retval != 0 and $retval != 18 and $type eq "ASCII"));
		close($fileb);
		$conn_prf->{ConnObj}->setopt(CURLOPT_UPLOAD,0);
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn_prf->{ConnObj}\n") and die;
	}

	return 0;

}

# rm_wrap()	Remove specified file via connection
#
# input parms	\%conn_prf	Connection Profile configuration values
# 		$file		File to remove
# 		$dir		Directory file is located
#
# returns			0 on success
# 				1 on general failure

sub rm_wrap($$$) {
	my($conn_prf) = shift;
	my($file) = shift;
	my($dir) = shift;

	if($conn_prf->{ConnObj} =~ /^Net::SFTP/) {
		$conn_prf->{ConnObj}->do_remove($dir . '/' . $file);
	} elsif($conn_prf->{ConnObj} =~ /^Net::FTP/) {
		$conn_prf->{ConnObj}->delete($dir . '/' . $file);
	} elsif($conn_prf->{ConnObj} =~ /^WWW::Curl/) {
		if($conn_prf->{ConnType} eq 'ftpes') {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftp://'.$conn_prf->{Server}.'/');
		} else {
			$conn_prf->{ConnObj}->setopt(CURLOPT_URL,'ftps://'.$conn_prf->{Server}.'/');
		}
		$conn_prf->{ConnObj}->setopt(CURLOPT_CUSTOMREQUEST,"DELE $dir/$file");
		my($fileb);
		open($fileb, "< $dir/$file");
			$conn_prf->{ConnObj}->setopt(CURLOPT_INFILE,$fileb);
			my $retval = curl_wrap($conn_prf);
			# FIXME: We get an unable to retrieve file when trying to delete? Unsure why, but ignore... for now.
			myprint(P_ERROR, "Error removing '$file': ".$conn_prf->{ConnObj}->strerror($retval)." ($retval)\n") and
				die if($retval != 0 and $retval != 19);
		close($fileb);
		$conn_prf->{ConnObj}->setopt(CURLOPT_CUSTOMREQUEST,"");
	} else {
		myprint(P_ERROR, "Unknown ConnType: $conn_prf->{ConnObj}\n") and die;
	}

	return 0;

}

# decrypt_wrap()	Conditionally decrypts files
#
# input parms	\%dir_prf	Directory Profile configuration values
#		$file		File to decrypt
#
# returns	$file2		Decrypted file on success
# 				Empty string on non encrypted file/no CryptType chosen

sub decrypt_wrap($$) {
	my($dir_prf) = shift;
	my($file) = shift;
	my($file2) = "";

	if($dir_prf->{CryptType} eq "PGP" and $file =~ m/^(.*)[.](asc|pgp)$/i) {
		$file2 = $1;

		myprint(P_INFO, "Decrypting $file with $dir_prf->{CryptType}/$dir_prf->{CryptData}\n");
		my($gpg) = new Crypt::GPG;
		$gpg->gpgbin('/usr/bin/gpg');
		$gpg->secretkey($dir_prf->{CryptData});
		$gpg->debug($dir_prf->{Debug});

		open(IN, "< $file")
			or (myprint(P_ERROR, "Can't open file $file for reading: $!\n") and die);
		my($data) = $gpg->decrypt([<IN>]);
		if(!defined($data) or $data eq "") {
			myprint(P_ERROR, "Error decrytping file $file: NO DATA\n");
			die;
		}
		close(IN);
		open(OUT, "> $file2")
			or (myprint(P_ERROR, "Can't open file $file2 for writing: $!\n") and die);
		print OUT $data;
		close(OUT);
	}

	return $file2;
}

# encrypt_wrap()	Conditionally encrypts files
#
# input parms	\%dir_prf	Directory Profile configuration values
#		$file		File to encrypt
#
# returns	$file2		Encrypted file on success
# 				Empty string on non encrypted file/no CryptType chosen

sub encrypt_wrap($$) {
	my($dir_prf) = shift;
	my($file) = shift;
	my($file2) = "";

	if($dir_prf->{CryptType} eq "PGP") {
		$file2 = $file.".asc";

		my($identity,$recipient) = split(/,/, $dir_prf->{CryptData});
		myprint(P_INFO, "Encrypting $file with $dir_prf->{CryptType}/$recipient\n");
		my($gpg) = new Crypt::GPG;
		$gpg->gpgbin('/usr/bin/gpg');
		$gpg->secretkey($identity);
		$gpg->encryptsafe(0);
		$gpg->debug($dir_prf->{Debug});

		open(IN, "< $dir_prf->{LocalDir}/$file")
			or (myprint(P_ERROR, "Can't open file $file for reading: $!\n") and die);
		my($cleartext) = join('', <IN>);
		close(IN);
		my(@crypted) = ();
		foreach my $line ($gpg->encrypt($cleartext, $recipient, -sign)) {
			if(!defined($line) or $line eq "") {
				myprint(P_ERROR, "Error encrytping file $file: NO DATA\n");
				die;
			}
			push(@crypted, $line);
		}
		open(OUT, "> $dir_prf->{LocalDir}/$file2")
			or (myprint(P_ERROR, "Can't open file $file2 for writing: $!\n") and die);
		foreach my $line (@crypted) {
			print OUT $line."\n";
		}
		close(OUT);
	}

	return $file2;
}

########################################################################################################
# Main
########################################################################################################

sub main($) {
	my(@argv) = @{(shift)};
	my($prog,$path) = get_progpath();
	my($test) = 0;

	if($#argv < 0 || $#argv > 1 || ($#argv == 0 && $argv[0] eq "--test")) {
		myprint(P_ERROR, "usage: $prog [--test] path_to_sndrcv.ini\n") and die;
	}

	if($argv[0] eq "--test") {
		$test = 1;
		shift @argv;
	}

	my($config) = get_config($argv[0]);

	my($date) = get_date();

	for my $key (keys %{$config}) {
		my($email_data) = { 'Message' => [] };

		$verbosity = $config->{$key}->{Verbosity};
		if($config->{$key}->{LogFile} ne "") {
			open(SAVEOUT, ">&STDOUT");
			open(SAVEERR, ">&STDERR");
			open(STDOUT, ">> $config->{$key}->{LogFile}")
				or (myprint(P_ERROR, "Can't open Log File $config->{$key}->{LogFile}: $!\n") and die);
			open(STDERR, ">&STDOUT");
		}

		if($config->{$key}->{EmailList} ne "") {
			my(@emaillist) = split(/,/, $config->{$key}->{EmailList});
			$email_data->{From} = shift(@emaillist);
			$email_data->{To} = join(',', @emaillist);
			$email_data->{Subject} = "File Transfer Notification for $key";
		}

		if($config->{$key}->{Active} eq "1" or $test == 1) {
			if(upload_loop($config->{$key}, $date, $email_data) != 0) {
				myprint(P_ERROR, "Error in upload loop!\n") and die;
			}

			if(download_loop($config->{$key}, $date, $email_data) != 0) {
				myprint(P_ERROR, "Error in download loop!\n") and die;
			}

			disconnect_wrap($config->{$key});
		} else {
			myprint(P_INFO, "Connection profile $key is Inactive.\n");
		}

		send_email($config->{$key}, $email_data) if(defined $email_data->{From});

		if($config->{$key}->{LogFile} ne "") {
			close(STDOUT);
			open(STDOUT, ">&SAVEOUT");
			open(STDERR, ">&SAVEERR");
		}
	}

	exit 0;
	close(SAVEOUT);
	close(SAVEERR);
}

main(\@ARGV);
